\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{enumitem}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue
}

\title{Florida Flood Gauge Monitor\\[0.5em]\large Documentation}
\author{Paul Fishwick and Claude Code}
\date{February 2026}

\begin{document}

\maketitle

\section{Overview}

The Florida Flood Gauge Monitor is a web application that displays real-time water level data from over 500 USGS monitoring stations across Florida. Users can explore an interactive map, view 7-day historical charts for individual gauges, and generate AI-powered narratives explaining water level behavior.

\section{Architecture}

The application uses a three-tier architecture that keeps API keys secure while serving a static frontend from GitHub Pages.

\subsection{System Overview}

\begin{verbatim}
  User's Browser
       |
       v
  GitHub Pages (static site)
       |
       |--- GET ---> USGS Water Services API (public, no key)
       |
       |--- POST --> Cloudflare Worker (serverless proxy)
                          |
                          |--- API key added server-side
                          v
                     Google Gemini API
\end{verbatim}

\subsection{Frontend (GitHub Pages)}

The static site is built with:

\begin{itemize}[nosep]
    \item \textbf{React + TypeScript} -- UI framework
    \item \textbf{Vite} -- Build tool and dev server
    \item \textbf{Leaflet} -- Interactive map rendering via OpenStreetMap
    \item \textbf{Recharts} -- Time series chart visualization
    \item \textbf{vite-plugin-pwa} -- Progressive Web App support (service worker, manifest, offline caching)
\end{itemize}

The frontend calls the USGS API directly (public, no key required) and routes all Gemini requests through the Cloudflare Worker proxy.

\subsection{Serverless API Proxy (Cloudflare Worker)}

A Cloudflare Worker acts as a secure intermediary between the frontend and the Google Gemini API. This pattern is essential because:

\begin{enumerate}[nosep]
    \item \textbf{API key security} -- The Gemini API key is stored as an encrypted secret on Cloudflare, never exposed in browser code or source repositories.
    \item \textbf{No server management} -- The Worker runs on Cloudflare's edge network. There is no server to maintain, patch, or scale.
    \item \textbf{Free tier} -- Cloudflare Workers provide 100,000 requests/day at no cost.
    \item \textbf{Reusable} -- The same Worker (or pattern) can serve multiple projects that need the same API key.
\end{enumerate}

The Worker is deployed at \texttt{api-proxy.metaphorz.workers.dev} and exposes a single endpoint:

\begin{itemize}[nosep]
    \item \texttt{POST /api/story} -- Accepts \texttt{prompt} and \texttt{systemInstruction} as JSON, forwards to Gemini, returns the generated text.
\end{itemize}

The Worker source code is located at \texttt{../api-proxy/api-proxy/src/index.ts} relative to the main project.

\subsubsection{Why Not Use \texttt{VITE\_} Environment Variables?}

Vite automatically inlines any environment variable prefixed with \texttt{VITE\_} into the JavaScript bundle at build time. This means a variable like \texttt{VITE\_GEMINI\_API\_KEY} becomes a plain string visible to anyone who inspects the deployed JavaScript. Removing the \texttt{VITE\_} prefix prevents Vite from inlining the value, but then the frontend cannot access it either. The serverless proxy solves this by keeping the key entirely server-side.

\subsubsection{Managing the Worker}

The Worker is managed using the \texttt{wrangler} CLI:

\begin{verbatim}
# Deploy updates
cd api-proxy/api-proxy && npx wrangler deploy

# Set or rotate the API key
echo "new_key_here" | npx wrangler secret put GEMINI_API_KEY

# View live logs
npx wrangler tail
\end{verbatim}

\subsection{Progressive Web App (PWA)}

The application is configured as a PWA, allowing users to install it on mobile devices and desktops:

\begin{itemize}[nosep]
    \item \textbf{Service Worker} -- Generated by \texttt{vite-plugin-pwa} during production builds. Precaches static assets for fast loading.
    \item \textbf{Web App Manifest} -- Defines the app name (``Florida Flood Gauge Monitor''), theme color, and icons for home screen installation.
    \item \textbf{Runtime Caching} -- USGS API responses are cached with a \texttt{NetworkFirst} strategy (5-minute expiration), so recent data is available even on flaky connections.
    \item \textbf{Icons} -- Custom gauge/water icons at 192x192 and 512x512 pixels.
\end{itemize}

To install: visit the deployed site in Chrome and click the install icon in the address bar, or on mobile Safari use Share $\rightarrow$ ``Add to Home Screen.''

\subsection{Data Flow}

\begin{enumerate}[nosep]
    \item On page load, the frontend fetches 7 days of gauge height data from the USGS Water Services API for all active Florida monitoring sites.
    \item Data is parsed, sorted chronologically, and rendered as map markers.
    \item When a user clicks a marker, a 7-day chart is displayed.
    \item When the user clicks ``Story,'' three requests (summary, standard, detailed) are sent to the Cloudflare Worker, which adds the API key and forwards them to Gemini.
    \item Responses are cached client-side so switching between detail levels is instant.
\end{enumerate}

\section{Features}

\subsection{Interactive Map}

The main view displays all active USGS flood gauges in Florida as blue markers on an OpenStreetMap base layer, as shown in Figure~\ref{fig:map}. Users can pan and zoom to explore gauge locations across the state.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{map-overview.png}
    \caption{Main map view showing 557 active USGS flood gauges across Florida.}
    \label{fig:map}
\end{figure}

\subsection{Gauge Chart}

Clicking on any gauge marker opens a bottom panel displaying a 7-day historical chart of water level changes, as shown in Figure~\ref{fig:chart}. The y-axis shows water level change in feet, and the x-axis shows the date range. A ``Story'' button is available to generate an AI explanation.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{gauge-chart.png}
    \caption{Historical water level chart for a selected gauge, with the Story button visible.}
    \label{fig:chart}
\end{figure}

\subsection{AI-Generated Story}

The Story feature uses Google Gemini to generate a narrative explanation of the water level data, as shown in Figure~\ref{fig:story}. Three detail levels are available:

\begin{itemize}[nosep]
    \item \textbf{Summary} -- One to two sentences
    \item \textbf{Standard} -- A single paragraph
    \item \textbf{Detailed} -- Two to three paragraphs
\end{itemize}

All three levels are fetched concurrently and cached, so switching between them is instant.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{gauge-story.png}
    \caption{AI-generated story modal explaining water level behavior for a selected gauge.}
    \label{fig:story}
\end{figure}

\section{Setup}

\subsection{Prerequisites}

\begin{itemize}[nosep]
    \item Node.js (v18+)
    \item npm
\end{itemize}

\subsection{Installation}

\begin{verbatim}
npm install
\end{verbatim}

\subsection{API Key Configuration}

The Gemini API key is stored securely on the Cloudflare Worker, not in the application code. The Story feature works automatically on the deployed site without any local key configuration.

For developers who wish to modify the Worker or rotate the key:

\begin{enumerate}[nosep]
    \item Obtain a free key at \url{https://aistudio.google.com}
    \item Store it in \texttt{\textasciitilde/.env} (home directory, outside the project):
\begin{verbatim}
GEMINI_API_KEY=your_key_here
\end{verbatim}
    \item Set it on the Worker:
\begin{verbatim}
cd api-proxy/api-proxy
echo "your_key_here" | npx wrangler secret put GEMINI_API_KEY
\end{verbatim}
\end{enumerate}

\textbf{Important:} Never use the \texttt{VITE\_} prefix for secret keys. Vite inlines \texttt{VITE\_}-prefixed variables into the JavaScript bundle, making them visible to all users.

\subsection{Running Locally}

\begin{verbatim}
./start
\end{verbatim}

This script kills any existing process on port 5173, starts the Vite dev server, and opens the browser.

\subsection{Deploying}

\begin{verbatim}
./deploy
\end{verbatim}

This script builds the production bundle (with PWA assets), verifies no secrets leaked into the output, clears the \texttt{gh-pages} cache, and publishes to GitHub Pages.

\section{License}

This project is released under the MIT License.

\end{document}
